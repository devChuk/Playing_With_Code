Let's talk about the compiler.


source code --> compiler                                                             --> executable code
				|																	|
				|																	|
				L-->lexer-->parser-->semantic analyzer-->optimizer-->code generator


					token identifier

							syntax analyzer

									provides "meaning". Dividing

														Not all compilers have an optimizer component. Will try to substitute your code with something faster.

																	where your code turns into some semblance of your original source code and becomes 1's and 0's

For MDL, we have to take care of these steps, except the optimization step.

>>Lexer
	It LEXES. WE'RE DONE HERE.
	It's going to identify the tokens of your language.
		Examples
				#'s, keywords, acceptable variable/identifier names, parenticies (HOW DO YOU SPELL THAT)

					for, int, true, while, false

								you can't have spaces in variable names, you can't start with a number

It will go through your code and create a list of tokens. Literally a list of tokens.

>>Parser
	While the Lexer knows valid tokens, while the Parser knows the syntax (grammar) of the language. I don't know why I'm capitalizing their names.
	Takes token list and creates a syntax tree

			(int)main----------------------------------------------return-----1
					|								|
					|								|
			        =------long-----x				print---x
					 |
					 +---6
					 |
  				 	 |
					 5										I tried.

>>Semantic Analyzer
	Takes this tree and apply MEANING to the tree.
		If it says print, then somewhere else, print must be defined.
			Thus, the SA attaches the definition to print.